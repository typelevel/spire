<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.1 + Helium Theme" />
    <title>Spire User&#39;s Guide</title>
    
      <meta name="author" content="Erik Osheim"/>
    
      <meta name="author" content="Tom Switzer"/>
    
    
      <meta name="description" content="docs"/>
    
    
      <link rel="icon" sizes="32x32" type="image/png" href="https://typelevel.org/img/favicon.png"/>
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="helium/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="site/styles.css" />
    <script src="helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>

      <a class="image-link" href="https://typelevel.org"><img src="https://typelevel.org/img/logo.svg"></a>

      <span class="row links"><a class="icon-link svg-link" href="https://www.javadoc.io/doc/org.typelevel/spire_2.13/latest/spire/index.html"><span title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a><a class="icon-link svg-link" href="https://github.com/typelevel/spire"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://fosstodon.org/@typelevel"><span class="mastodon" title="Mastodon"><svg class="svg-icon svg-link" width="100%" height="100%" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"/>
  </g>
</svg>
</span></a></span>

    </header>

    <nav id="sidebar">

      <div class="row">
        <a class="icon-link svg-link" href="https://www.javadoc.io/doc/org.typelevel/spire_2.13/latest/spire/index.html"><span title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a><a class="icon-link svg-link" href="https://github.com/typelevel/spire"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://fosstodon.org/@typelevel"><span class="mastodon" title="Mastodon"><svg class="svg-icon svg-link" width="100%" height="100%" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"/>
  </g>
</svg>
</span></a>
      </div>

      <ul class="nav-list">
        <li class="level1"><a href="index.html">Spire</a></li>
        <li class="level1 active"><a href="#">Spire User&#39;s Guide</a></li>
        <li class="level1"><a href="CHANGES.html">Changes</a></li>
        <li class="level1"><a href="CONTRIBUTING.html">Contributing to Spire</a></li>
        <li class="level1"><a href="DESIGN.html">Design</a></li>
        <li class="level1"><a href="AUTHORS.html">Authors</a></li>
        <li class="level1"><a href="FRIENDS.html">Friends of Spire</a></li>
      </ul>

      <ul class="nav-list">
        <li class="level1 nav-header">Related Projects</li>
        
          <li class="level2"><a href="https://typelevel.org/cats/">cats</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">Spire User&#39;s Guide</a></p>

        <ul class="nav-list">
          <li class="level1"><a href="#type-classes-1">Type Classes</a></li>
          <li class="level2"><a href="#package-layout">Package Layout</a></li>
          <li class="level2"><a href="#usage">Usage</a></li>
          <li class="level2"><a href="#specialization">Specialization</a></li>
          <li class="level1"><a href="#type-classes-2">Type Classes</a></li>
          <li class="level2"><a href="#properties">Properties</a></li>
          <li class="level2"><a href="#eq">Eq</a></li>
          <li class="level2"><a href="#order">Order</a></li>
          <li class="level2"><a href="#signed">Signed</a></li>
          <li class="level2"><a href="#partialorder">PartialOrder</a></li>
          <li class="level2"><a href="#groups">Groups</a></li>
          <li class="level2"><a href="#rings-and-fields">Rings and Fields</a></li>
          <li class="level2"><a href="#commutative-ring-hierarchy">Commutative ring hierarchy</a></li>
          <li class="level2"><a href="#gcdrings">GCDRings</a></li>
          <li class="level2"><a href="#euclideanrings">EuclideanRings</a></li>
          <li class="level2"><a href="#fields">Fields</a></li>
          <li class="level2"><a href="#irrational-and-transcendental-type-classes">Irrational and Transcendental type classes</a></li>
          <li class="level2"><a href="#modules-vectorspaces-co">Modules, VectorSpaces, &amp;co</a></li>
          <li class="level1"><a href="#types">Types</a></li>
          <li class="level2"><a href="#byte-short-int-and-long">Byte, Short, Int, and Long</a></li>
          <li class="level2"><a href="#float-and-double">Float and Double</a></li>
          <li class="level2"><a href="#bigint">BigInt</a></li>
          <li class="level2"><a href="#bigdecimal">BigDecimal</a></li>
          <li class="level2"><a href="#rational">Rational</a></li>
          <li class="level2"><a href="#safelong">SafeLong</a></li>
          <li class="level2"><a href="#natural">Natural</a></li>
          <li class="level2"><a href="#ubyte-ushort-uint-and-ulong">UByte, UShort, UInt, and ULong</a></li>
          <li class="level2"><a href="#fixedpoint">FixedPoint</a></li>
          <li class="level2"><a href="#complex-a-and-quaternion-a">Complex[A] and Quaternion[A]</a></li>
          <li class="level2"><a href="#number">Number</a></li>
          <li class="level2"><a href="#interval-a">Interval[A]</a></li>
          <li class="level2"><a href="#polynomial-c">Polynomial[C]</a></li>
          <li class="level2"><a href="#algebraic">Algebraic</a></li>
          <li class="level2"><a href="#real">Real</a></li>
          <li class="level1"><a href="#which-number-types-should-i-use">Which number types should I use?</a></li>
          <li class="level2"><a href="#natural-numbers-unsigned-whole-value-numbers">Natural numbers (unsigned, whole-value numbers)</a></li>
          <li class="level2"><a href="#integer-numbers-signed-whole-value-numbers">Integer numbers (signed, whole-value numbers)</a></li>
          <li class="level2"><a href="#fractional-numbers-numbers-that-can-be-divided">Fractional numbers (numbers that can be divided)</a></li>
          <li class="level2"><a href="#other-types">Other types</a></li>
          <li class="level1"><a href="#pseudo-random-number-generators-distributions-etc">Pseudo-Random Number Generators, Distributions, etc</a></li>
          <li class="level2"><a href="#pseudo-random-number-generators">Pseudo-Random Number Generators</a></li>
          <li class="level2"><a href="#creation-random-values-with-dist-a">Creation random values with Dist[A]</a></li>
          <li class="level2"><a href="#distributions">Distributions</a></li>
        </ul>

        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="spire-user-s-guide" class="title">Spire User&#39;s Guide</h1>
        <p>This guide explains the architecture, layout, and usage of Spire. Initially,
        we will explore some of the basic structures and patterns used by Spire. Then,
        we&#39;ll look at many of the concrete types that Spire defines. Finally, we&#39;ll
        peek at some of the advanced or tricky corners of the library.</p>
        
        <h3 id="type-classes-1" class="section">Type Classes<a class="anchor-link right" href="#type-classes-1"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>Like many Scala libraries, Spire uses type classes to define generic
        operations.</p>
        <p>These code examples all assume the following imports:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">algebra</span><span>.</span><span class="identifier">_</span><span>   </span><span class="comment">// all type class definitions
</span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span> </span><span class="comment">// all type class instances and syntax</span></code></pre>
        <p>For example, <code>Ring[A]</code> is a type class that defines many basic operations,
        such as <code>+</code> and <code>*</code> on a type <code>A</code>. When using type classes it&#39;s important to
        try to distinguish the following:</p>
        <ol class="arabic">
          <li>The type class itself (<code>Ring[A]</code>). This is often a trait.</li>
        </ol>
        <ol class="arabic">
          <li>Concrete instances of the type class, such as <code>Ring[Int]</code>.</li>
        </ol>
        <ol class="arabic">
          <li>Syntax implicits that use the type class to define operators.</li>
        </ol>
        <p>The methods in these type classes are always given text names (like
        <code>plus</code>). In some cases these names correspond to symbolic operators:
        in the case of <code>plus</code>, it corresponds with <code>+</code>. When using these type
        classes, users have the option of using the symbolic syntax on the
        values directly or calling the method on the type class instance:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">usingSymbols</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Ring</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">usingNames</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">r</span><span>: </span><span class="type-name">Ring</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">A</span><span> = </span><span class="identifier">r</span><span>.</span><span class="identifier">plus</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)</span></code></pre>
        <p>Some methods (e.g. <code>sqrt</code>) do not have corresponding symbols. In those
        cases, the method name itself can be used with the values:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">sqrt</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">NRoot</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span>.</span><span class="identifier">sqrt</span></code></pre>
        
        <h4 id="package-layout" class="section">Package Layout<a class="anchor-link right" href="#package-layout"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>In the case of <code>Ring[A]</code>, the type class itself is located in
        <code>spire.algebra</code>. Except for a few special cases, all of Spire&#39;s type
        classes can be found in <code>spire.algebra</code>.</p>
        <p>Type class instances can be found in two different places. For types
        defined in Spire, or code that is aware of Spire, type class instances
        should be placed in the type&#39;s companion object. For example, <code>UByte</code>
        (an unsigned byte type) has an instance of <code>Rig[UByte]</code> contained in
        its companion object.</p>
        <p>For types defined elsewhere that Spire supports directly (for example
        the built-in number types) Spire defines objects in <code>spire.std</code> which
        contain their instances. So to get all the instances for <code>Int</code> you&#39;d
        import them from <code>spire.std.int._</code>. To get all these &quot;standard
        instances&quot; at one go, import <code>spire.std.any._</code>. This pattern should
        also be used when supporting other number types that are not
        Spire-aware.</p>
        <p>Finally, syntax implicits are imported from objects in
        <code>spire.syntax</code>. To get the syntax for <code>Ring[A]</code> you&#39;d import
        <code>spire.syntax.ring._</code>. Again, there is a shortcut package: you can
        import <code>spire.syntax.all._</code> to get all syntax.</p>
        <p>These imports might seem a bit confusing, but they are very useful
        when you find a situation where Spire&#39;s types or operators conflict
        with another library&#39;s.  We provide an even more basic import
        (<code>spire.implicits._</code>) for when you want all instances and all
        operators. This is nice when working in the console or experimenting,
        and for when you&#39;re sure there won&#39;t be a conflict.</p>
        
        <h4 id="usage" class="section">Usage<a class="anchor-link right" href="#usage"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Most of the time, you&#39;ll be using type classes as context bounds. For
        instance:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Demo</span><span> {
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">algebra</span><span>.</span><span class="identifier">_</span><span>
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">std</span><span>.</span><span class="identifier">any</span><span>.</span><span class="identifier">_</span><span>
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">ring</span><span>.</span><span class="identifier">_</span><span>

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">double</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Ring</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span> + </span><span class="identifier">x</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">triple</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Ring</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span> * </span><span class="number-literal">3</span><span>
  </span><span class="identifier">println</span><span>((</span><span class="identifier">double</span><span>(</span><span class="number-literal">3</span><span>), </span><span class="identifier">triple</span><span>(</span><span class="number-literal">4</span><span>)))
}</span></code></pre>
        <p>This code ends up being equivalent to:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Demo2</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">double</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ev</span><span>: </span><span class="type-name">Ring</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">A</span><span> = </span><span class="identifier">ev</span><span>.</span><span class="identifier">plus</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">x</span><span>)
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">triple</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ev</span><span>: </span><span class="type-name">Ring</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">A</span><span> = </span><span class="identifier">ev</span><span>.</span><span class="identifier">times</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">ev</span><span>.</span><span class="identifier">fromInt</span><span>(</span><span class="number-literal">3</span><span>))
  </span><span class="identifier">println</span><span>((</span><span class="identifier">double</span><span>(</span><span class="number-literal">3</span><span>)(</span><span class="type-name">IntAlgebra</span><span>), </span><span class="identifier">triple</span><span>(</span><span class="number-literal">4</span><span>)(</span><span class="type-name">IntAlgebra</span><span>)))
}</span></code></pre>
        <p>The <code>IntAlgebra</code> type extends <code>Ring[Int]</code> and has been imported via
        <code>spire.std.any._</code>. The implicits providing the binary operators <code>+</code>
        and <code>*</code> (and also the implicit to convert the integer literal into an
        <code>A</code>) were all imported form <code>spire.syntax.ring._</code>. And the <code>Ring</code>
        context bound is really just sugar for an implicit parameter (the type
        class instance).</p>
        <p>Hopefully this small example gives you an idea of the basic mechanics
        behind Spire&#39;s generic math capabilities.</p>
        
        <h4 id="specialization" class="section">Specialization<a class="anchor-link right" href="#specialization"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>To achieve speed on-par with direct (non-generic) code, you will need
        to use <a href="https://www.scala-lang.org/old/sites/default/files/sids/dragos/Thu,%202010-05-06,%2017:56/sid-spec.pdf">specialization</a>. The good news is that most of Spire&#39;s code is
        already specialized (and tested for proper performance). The bad news
        is that you&#39;ll have to annotate all your generic code like so:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Demo3</span><span> {
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">algebra</span><span>.</span><span class="identifier">_</span><span>
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">std</span><span>.</span><span class="identifier">any</span><span>.</span><span class="identifier">_</span><span>
  </span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">ring</span><span>.</span><span class="identifier">_</span><span>
  
  </span><span class="keyword">import</span><span> </span><span class="identifier">scala</span><span>.{</span><span class="identifier">specialized</span><span> =&gt; </span><span class="identifier">sp</span><span>}

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">double</span><span>[</span><span class="annotation">@sp</span><span> </span><span class="type-name">A</span><span>: </span><span class="type-name">Ring</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span> + </span><span class="identifier">x</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">triple</span><span>[</span><span class="annotation">@sp</span><span> </span><span class="type-name">A</span><span>: </span><span class="type-name">Ring</span><span>](</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">A</span><span> = </span><span class="identifier">x</span><span> * </span><span class="number-literal">3</span><span>
  </span><span class="identifier">println</span><span>((</span><span class="identifier">double</span><span>(</span><span class="number-literal">3</span><span>), </span><span class="identifier">triple</span><span>(</span><span class="number-literal">4</span><span>)))
}</span></code></pre>
        <p>There are too many gotchas with specialization to list here. But the
        (very) short guide to specialization is:</p>
        <ol class="arabic">
          <li>It&#39;s much easier to specialize methods.</li>
        </ol>
        <ol class="arabic">
          <li>Calls from generic code into specialized code are not specialized.</li>
        </ol>
        <ol class="arabic">
          <li>Limit specialization to types you&#39;ll use via <code>@sp(Int, Double)</code>.</li>
        </ol>
        <ol class="arabic">
          <li>Specialization will increase bytecode size by a factor of x2-10.</li>
        </ol>
        <p>If you have questions about specialization feel free to ask on the
        <code>#spire</code> channel on the <a href="https://discord.com/invite/XF3CXcMzqD">Typelevel Discord</a>.
        You may notice that some code in Spire is structured in
        an unusual way, and often this is to make sure specialization works
        properly.</p>
        <p>You may find that it&#39;s easy to develop generic code without using
        specialization first (to keep things simple) and then going back and
        adding annotations later if necessary. This helps keep things simple
        while you get your code working correctly, and it&#39;s a (relatively)
        minor change to enable specialization later (as long as you are
        consistent).</p>
        <p>Of course, if your code is not generic, you can call into Spire&#39;s
        specialized code without worrying about any of this (and the result
        will be unboxed and fast).</p>
        
        <h3 id="type-classes-2" class="section">Type Classes<a class="anchor-link right" href="#type-classes-2"><i class="icofont-laika">&#xef71;</i></a></h3>
        
        <h4 id="properties" class="section">Properties<a class="anchor-link right" href="#properties"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Spire&#39;s type classes are often described in terms of properties (or
        &quot;laws&quot;).  These properties must be true no matter what values are
        used.</p>
        <p>Here&#39;s a brief description of some of the most common properties:</p>
        <ul>
          <li><em>associativity</em>: <code>|+|</code> is associative if <code>(a |+| b) |+| c</code> = <code>a |+| (b |+| c)</code>.</li>
        </ul>
        <ul>
          <li><em>identity</em>: <code>id</code> is an identity value for <code>|+|</code> if <code>a |+| id</code> = <code>a</code> = <code>id |+| a</code>.</li>
        </ul>
        <ul>
          <li><em>inverse</em>: <code>|+|</code> has an <code>inverse</code> operation if <code>a |+| a.inverse</code> = <code>id</code> = <code>a.inverse |+| a</code>.</li>
        </ul>
        <ul>
          <li><em>commutativity</em>: <code>|+|</code> is commutative if <code>a |+| b</code> = <code>b |+| a</code>.</li>
        </ul>
        <p>In some cases the operator names are different (e.g. <code>+</code>, <code>*</code>) but the
        properties themselves remain the same.</p>
        
        <h4 id="eq" class="section">Eq<a class="anchor-link right" href="#eq"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Spire provides an <code>Eq[A]</code> type class to represent type-safe
        equality. This allows us to talk about types for which there isn&#39;t a
        computationally useful notion of equality, and also to avoid
        programming errors caused by universal equality.</p>
        <p><code>Eq[A]</code> provides two operators</p>
        <ul>
          <li><code>eqv</code> (<code>a === b</code>) equality operator.</li>
        </ul>
        <ul>
          <li><code>neqv</code> (<code>a =!= b</code>) inequality operator (defaults to <code>!(a === b)</code>).</li>
        </ul>
        <p>Spire requires that <code>eqv</code> obey the laws of an equivalence relation, namely:</p>
        <ul>
          <li><code>a === a</code> (<em>reflexivity</em>)</li>
        </ul>
        <ul>
          <li>if <code>a === b</code> then <code>b === a</code> (<em>symmetry</em>)</li>
        </ul>
        <ul>
          <li>if <code>a === b</code> then <code>a</code> is <code>b</code> (<em>anti-symmetry</em>)</li>
        </ul>
        <ul>
          <li>if <code>a === b</code> and <code>b === c</code> then <code>a === c</code> (<em>transitivity</em>)</li>
        </ul>
        <p>The anti-symmetry property may seem confusing. The idea is that if <code>a === b</code>
        then <code>a</code> and <code>b</code> must be substitutable for each other, such that for any
        expression <code>f(x)</code>, <code>f(a) === f(b)</code>.</p>
        
        <h4 id="order" class="section">Order<a class="anchor-link right" href="#order"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Total orderings in Spire are supported by the <code>Order[A]</code> type
        class. Unlike other ordering type classes
        (e.g. <code>scala.math.Ordering</code>), this one is specialized to avoid boxing.
        <code>Order[A]</code> extends <code>Eq[A]</code> can be implemented via a single <code>compare</code>
        method, although it provides all of the following:</p>
        <ul>
          <li><code>eqv</code> (<code>a === b</code>)</li>
        </ul>
        <ul>
          <li><code>neqv</code> (<code>a =!= b</code>)</li>
        </ul>
        <ul>
          <li><code>lt</code> (<code>a &lt; b</code>)</li>
        </ul>
        <ul>
          <li><code>gt</code> (<code>a &gt; b</code>)</li>
        </ul>
        <ul>
          <li><code>lteqv</code> (<code>a &lt;= b</code>)</li>
        </ul>
        <ul>
          <li><code>gteqv</code> (<code>a &gt;= b</code>)</li>
        </ul>
        <ul>
          <li><code>compare</code> (<code>a compare b</code>)</li>
        </ul>
        <ul>
          <li><code>min</code> (<code>a min b</code>)</li>
        </ul>
        <ul>
          <li><code>max</code> (<code>a max b</code>)</li>
        </ul>
        <p>Instances of <code>Order[A]</code> are required to observe the following
        properties:</p>
        <ul>
          <li>if <code>a &lt;= b</code> and <code>b &lt;= a</code> then <code>a === b</code> (<em>anti-symmetry</em>)</li>
        </ul>
        <ul>
          <li>if <code>a &lt;= b</code> and <code>b &lt;= c</code> then <code>a &lt;= c</code> (<em>transitivity</em>)</li>
        </ul>
        <ul>
          <li>either <code>a &lt;= b</code> or <code>b &lt;= a</code> (<em>totality</em>)</li>
        </ul>
        <p>Additionally, total orderings across fields should obey the following
        additional laws:</p>
        <ul>
          <li>if <code>a &lt;= b</code> then <code>(a + c) &lt;= (b + c)</code> (<em>O1</em>)</li>
        </ul>
        <ul>
          <li>if <code>zero &lt;= a</code> and <code>zero &lt;= b</code> then <code>zero &lt;= (a * b)</code> (<em>O2</em>)</li>
        </ul>
        <p>(These are laws are required by ordered fields.)</p>
        <p>In some cases users may need to use (or define) total orderings that
        do not follow all these laws, or may break laws required by other
        structures. An example would be the lexicographic ordering of complex
        numbers, which breaks <em>O2</em>.  In these cases, users will need to be
        aware of the risks and limit their use to situations where the
        particular law is not needed.</p>
        
        <h4 id="signed" class="section">Signed<a class="anchor-link right" href="#signed"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Translation-invariant total orders are captured by the <code>Signed[A]</code> type class. In
        general, the type <code>A</code> is equipped with a commutative additive operation <code>+</code> and a
        zero element <code>0</code> (see the definition of commutative rings below). The following
        laws hold:</p>
        <ul>
          <li>if <code>a &lt;= b</code> then <code>a + c &lt;= b + c</code> (linear order),</li>
        </ul>
        <ul>
          <li><code>signum(x) = -1</code> if <code>x &lt; 0</code>, <code>signum(x) = 1</code> if <code>x &gt; 0</code>, <code>signum(x) = 0</code> otherwise.</li>
        </ul>
        <p>If the type <code>A</code> is equipped with negative elements <code>-x</code>, then we have:</p>
        <ul>
          <li><code>abs(x) = -x</code> if <code>x &lt; 0</code>, or <code>x</code> otherwise,</li>
        </ul>
        <p>The above laws imply:</p>
        <ul>
          <li><code>abs(a + b) &lt;= abs(a) + abs(b)</code></li>
        </ul>
        
        <h4 id="partialorder" class="section">PartialOrder<a class="anchor-link right" href="#partialorder"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Partial orderings in Spire are supported by the <code>PartialOrder[A]</code> type class.
        Its implementation differs from <code>scala.math.PartialOrdering</code> in two features: <code>PartialOrder</code>
        is specialized to avoid boxing, and the <code>partialCompare</code> method returns a <code>Double</code> and
        avoids allocation of an <code>Option[Int]</code> instance. <code>PartialOrder[A]</code> extends <code>Eq[A]</code>, and can
        be implemented via a single <code>partialCompare</code> method, described below. <code>PartialOrder</code> provides:</p>
        <ul>
          <li><code>eqv</code> (<code>a === b</code>)</li>
        </ul>
        <ul>
          <li><code>neqv</code> (<code>a =!= b</code>)</li>
        </ul>
        <ul>
          <li><code>lt</code> (<code>a &lt; b</code>)</li>
        </ul>
        <ul>
          <li><code>gt</code> (<code>a &gt; b</code>)</li>
        </ul>
        <ul>
          <li><code>lteqv</code> (<code>a &lt;= b</code>)</li>
        </ul>
        <ul>
          <li><code>gteqv</code> (<code>a &gt;= b</code>)</li>
        </ul>
        <ul>
          <li><code>partialCompare</code> (<code>a partialCompare b</code>)</li>
        </ul>
        <ul>
          <li><code>tryCompare</code> (<code>a tryCompare b</code>)</li>
        </ul>
        <ul>
          <li><code>pmin</code> (<code>a pmin b</code>) -- returns the least element if they can be compared</li>
        </ul>
        <ul>
          <li><code>pmax</code> (<code>a pmax b</code>) -- returns the greatest element if they can be compared</li>
        </ul>
        <p>A partial order is defined from a binary relation <code>&lt;=</code>, which satisfies the relations:</p>
        <ul>
          <li><code>a &lt;= a</code> (<em>reflexivity</em>)</li>
          <li>if <code>a &lt;= b</code> and <code>b &lt;= a</code>, then <code>a === b</code> (<em>anti-symmetry</em>)</li>
          <li>if <code>a &lt;= b</code> and <code>b &lt;= c</code>, then <code>a &lt;= c</code> (<em>transitivity</em>)</li>
        </ul>
        <p>To compute both <code>&lt;=</code> and <code>&gt;=</code> at the same time, the method <code>partialCompare</code> uses
        a <code>Double</code> number to encode the result of both comparisons. The truth table is defined as follows:</p>
        <table>
          <thead>
            <tr>
              <th class="align-center"><code>a &lt;= b</code></th>
              <th class="align-center"><code>a &gt;= b</code></th>
              <th class="align-center"><code>partialCompare(a, b)</code></th>
              <th class="align-center">corresponds to</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="align-center"><code>true</code></td>
              <td class="align-center"><code>true</code></td>
              <td class="align-center"><code>0</code></td>
              <td class="align-center"><code>a === b</code></td>
            </tr>
            <tr>
              <td class="align-center"><code>false</code></td>
              <td class="align-center"><code>false</code></td>
              <td class="align-center"><code>NaN</code></td>
              <td class="align-center"><code>a</code> incomparable with <code>b</code></td>
            </tr>
            <tr>
              <td class="align-center"><code>true</code></td>
              <td class="align-center"><code>false</code></td>
              <td class="align-center"><code>-1</code></td>
              <td class="align-center"><code>a &lt; b</code></td>
            </tr>
            <tr>
              <td class="align-center"><code>false</code></td>
              <td class="align-center"><code>true</code></td>
              <td class="align-center"><code>1</code></td>
              <td class="align-center"><code>a &gt; b</code></td>
            </tr>
          </tbody>
        </table>
        <p>The method <code>tryCompare</code> returns maps <code>-1.0</code>, <code>0.0</code>, <code>1.0</code> to <code>Some(-1)</code>, <code>Some(0)</code>, <code>Some(1)</code>,
        and <code>NaN</code> to <code>None</code>, allowing the use of <code>getOrElse</code> and higher-order methods, at the price of an
        <code>Option[Int]</code> allocation.</p>
        <p>Instances of <code>PartialOrder[A]</code> are required to observe the properties above.</p>
        <p>Note that <code>Order[A]</code> extends <code>PartialOrder[A]</code>, but for pedagogical purposes, <code>Order[A]</code> is presented first
        in this guide.</p>
        
        <h4 id="groups" class="section">Groups<a class="anchor-link right" href="#groups"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>The most basic algebraic type classes Spire supports involve a single
        associative binary operator (called <code>op</code> and represented as <code>|+|</code>):</p>
        <ul>
          <li><code>Semigroup[A]</code> just the associative operator <code>|+|</code>, nothing more.</li>
        </ul>
        <ul>
          <li><code>Monoid[A]</code> a semigroup that also has an identity element <code>id</code>.</li>
        </ul>
        <ul>
          <li><code>Group[A]</code> a monoid that also has an inverse operation (<code>inverse</code> or <code>|-|</code>).</li>
        </ul>
        <ul>
          <li><code>CSemigroup[A]</code> a semigroup that is commutative.</li>
        </ul>
        <ul>
          <li><code>CMonoid[A]</code> a monoid that is commutative.</li>
        </ul>
        <ul>
          <li><code>AbGroup[A]</code> an &quot;abelian group&quot;, a group that is commutative.</li>
        </ul>
        <p>Most types have many possible implementations of these types
        classes. In these cases Spire requires users to explicitly choose
        which implementation they want.</p>
        <p>Spire also defines two parallel group hierarchies for <em>additive</em> and
        <em>multiplicative</em> groups. These have the same properties but different
        names and symbols. The following list provides the generic, additive,
        and multiplicative variants:</p>
        <ul>
          <li>operator method: <code>op</code>, <code>plus</code>, <code>times</code></li>
        </ul>
        <ul>
          <li>operator symbol: <code>|+|</code>, <code>+</code>, <code>*</code></li>
        </ul>
        <ul>
          <li>identity name: <code>id</code>, <code>zero</code>, <code>one</code></li>
        </ul>
        <ul>
          <li>inverse method: <code>inverse</code>, <code>negate</code>, <code>reciprocal</code></li>
        </ul>
        <ul>
          <li>inverse symbol: <code>inverse</code>, <code>-</code> (unary), <code>reciprocal</code></li>
        </ul>
        <ul>
          <li>inverse binary operator: <code>|-|</code>, <code>-</code> (binary), <code>/</code></li>
        </ul>
        
        <h4 id="rings-and-fields" class="section">Rings and Fields<a class="anchor-link right" href="#rings-and-fields"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Rings are a set together with two binary operation (additive and
        multiplicative). Spire defines these by extending the appropriate
        additive and multiplicative group traits. The following list roughly
        describes the Ring-like type classes Spire provides:</p>
        <ul>
          <li><code>Semiring[A]</code> provides <code>+</code>, <code>zero</code>, and <code>*</code>.</li>
        </ul>
        <ul>
          <li><code>Rig[A]</code> provides <code>+</code>, <code>zero</code>, <code>*</code>, and <code>one</code>.</li>
        </ul>
        <ul>
          <li><code>Rng[A]</code> provides commutative <code>+</code>, <code>zero</code>, <code>-</code>, and <code>*</code>.</li>
        </ul>
        <ul>
          <li><code>Ring[A]</code> provides commutative <code>+</code>, <code>zero</code>, <code>-</code>, <code>*</code>, and <code>one</code>.</li>
        </ul>
        <ul>
          <li><code>CRing[A]</code> provides commutative <code>+</code>, <code>zero</code>, <code>-</code>, commutative <code>*</code>, and <code>one</code>.</li>
        </ul>
        <p>The following list makes clear how these type classes are defined via
        inheritance:</p>
        <ul>
          <li><code>Semiring[A]</code> extends <code>AdditiveMonoid[A]</code> with <code>MultiplicativeSemigroup[A]</code></li>
        </ul>
        <ul>
          <li><code>Rig[A]</code> extends <code>Semiring[A]</code> with <code>MultiplicativeMonoid[A]</code></li>
        </ul>
        <ul>
          <li><code>Rng[A]</code> extends <code>Semiring[A]</code> with <code>AdditiveAbGroup[A]</code></li>
        </ul>
        <ul>
          <li><code>Ring[A]</code> extends <code>Rig[A]</code> with <code>Rng[A]</code></li>
        </ul>
        <ul>
          <li><code>CRing[A]</code> extends <code>Ring[A]</code> with <code>MultiplicativeCMonoid[A]</code></li>
        </ul>
        <p>Rings also provide a <code>pow</code> method (<code>**</code>) for doing repeated multiplication.</p>
        
        <h4 id="commutative-ring-hierarchy" class="section">Commutative ring hierarchy<a class="anchor-link right" href="#commutative-ring-hierarchy"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Commutative rings (also called domains in the literature) have a rich
        structure.</p>
        <p>Spire focuses on the structures relevant for computational algebra
        (GCD rings, Euclidean rings and fields).</p>
        <ul>
          <li><code>GCDRing[A]</code> extends <code>CRing[A]</code></li>
        </ul>
        <ul>
          <li><code>EuclideanRing[A]</code> extends <code>GCDRing[A]</code></li>
        </ul>
        <ul>
          <li><code>spire.Field[A]</code> extends<code>algebra.Field[A]</code> with <code>EuclideanRing[A]</code></li>
        </ul>
        
        <h4 id="gcdrings" class="section">GCDRings<a class="anchor-link right" href="#gcdrings"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>GCDRings are commutative rings (<code>CRing[A]</code>) with existence of a
        greatest-common-divisor and least-common-multiple.</p>
        <p>Spire&#39;s <code>GCDRing[A]</code> supports the following operations:</p>
        <ul>
          <li><code>gcd</code> (<code>a gcd b</code>) find the greatest common divisor of <code>a</code> and <code>b</code>.</li>
        </ul>
        <ul>
          <li>
            <p><code>lcm</code> (<code>a lcm b</code>) find the lowest common multiple of <code>a</code> and <code>b</code>.</p>
            <p>obeying the following laws:</p>
          </li>
        </ul>
        <ul>
          <li><code>d * m === a * b</code> for <code>d = gcd(a, b)</code> and <code>m = lcm(a, b)</code>,</li>
        </ul>
        <ul>
          <li>gcd is associative and commutative,</li>
        </ul>
        <ul>
          <li>lcm is associative and commutative.</li>
        </ul>
        <p>Note that the gcd is defined up to a divisible element (unit);
        in particular, its sign is a matter of convention. </p>
        <p>Spire requires these operations to be commutative. Note that fields
        have leeway to define the GCD operation. In practice, instances of
        <code>Field[A]</code> provide either a trivial implementation <code>gcd(x != 0 , y != 0) == 1</code>
        or a definition that extends the one used for the integer ring
        (<code>gcd(a/b, c/d) == gcd(a, c)/lcm(b, d)</code>).</p>
        
        <h4 id="euclideanrings" class="section">EuclideanRings<a class="anchor-link right" href="#euclideanrings"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Spire supports euclidean domains (called <code>EuclideanRing[A]</code>). A
        euclidean domain is a GCD ring (<code>GCDRing[A]</code>) that also supports
        euclidean division (e.g. floor division or integer division). This
        structure generalizes many useful properties of the integers (for
        instance, quotients and remainders, and greatest common divisors).</p>
        <p>Formally, euclidean domains have a <em>euclidean function</em> f such that
        for any <code>x</code> and <code>y</code> in <code>A</code>, if <code>y</code> is nonzero, then there are <code>q</code> and
        <code>r</code> (quotient and remainder) such that <code>a = b*q + r</code> and <code>r = 0</code> or
        <code>f(r) &lt; f(b)</code>. For integers, <code>f</code> is usually the absolute value
        function.</p>
        <p>Spire&#39;s <code>EuclideanRing[A]</code> supports the following operations:</p>
        <ul>
          <li><code>quot</code> (<code>a /~ b</code>) finding the quotient.</li>
        </ul>
        <ul>
          <li><code>mod</code> (<code>a % b</code>) the remainder from the quotient operation.</li>
        </ul>
        <ul>
          <li><code>quotmod</code> (<code>a /% b</code>) combines <code>quot</code> and <code>mod</code> into one operation.</li>
        </ul>
        <p>Spire requires that <code>b * (a /~ b) + (a % b)</code> is equivalent to <code>a</code>.</p>
        <p>On integers, Euclidean quotient and remainder corresponds to
        truncated division; however, the sign of the result is a matter
        of convention. On rational (or floating-point) numbers, <code>a /~ b = a / b</code>
        and <code>a % b = 0</code> by definition.</p>
        
        <h4 id="fields" class="section">Fields<a class="anchor-link right" href="#fields"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Fields are commutative rings with commutative multiplication and
        multiplicative inverses for all non-zero elements. Fields generalize
        how most people think about rational numbers.</p>
        <p>Spire&#39;s <code>Field[A]</code> supports the following operations:</p>
        <ul>
          <li><code>div</code> (<code>a / b</code>) divide <code>a</code> by <code>b</code>.</li>
        </ul>
        <ul>
          <li><code>reciprocal</code> (<code>a.reciprocal</code>) the multiplicative inverse of <code>a</code>, i.e. <code>one/a</code>.</li>
        </ul>
        <p>Even though fields sit at the top of the ring hierarchy, there are
        many operations which are not provided by fields:</p>
        <ul>
          <li>equality and ordering (provided by <code>Eq[A]</code> and <code>Order[A]</code>).</li>
        </ul>
        <ul>
          <li>square root, and other roots (provided by <code>NRoot[A]</code>).</li>
        </ul>
        <ul>
          <li>sine, cosine, and trigonometric functions (provided by <code>Trig[A]</code>).</li>
        </ul>
        
        <h4 id="irrational-and-transcendental-type-classes" class="section">Irrational and Transcendental type classes<a class="anchor-link right" href="#irrational-and-transcendental-type-classes"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Spire supports square roots and fractional powers via
        <code>NRoot[A]</code>. There are three basic methods available:</p>
        <ul>
          <li><code>sqrt</code> (<code>a.sqrt</code>) finds the square root of <code>a</code></li>
        </ul>
        <ul>
          <li><code>nroot</code> (<code>(a nroot k)</code>) finds the kth root of <code>a</code></li>
        </ul>
        <ul>
          <li><code>fpow</code> (<code>(a fpow b)</code>) takes <code>a</code> to the fractional power <code>b</code></li>
        </ul>
        <p>Spire does not have any fractional types that can represent irrational
        roots exactly. This means that many laws we might like to write about
        roots will be weaker than we would like:</p>
        <ul>
          <li><code>a.sqrt</code> = <code>(a nroot 2)</code> = <code>(a fpow 2.reciprocal)</code></li>
        </ul>
        <ul>
          <li>if <code>A</code> can represent <code>1/k</code> exactly, then <code>(a nroot k)</code> = <code>(a fpow k.reciprocal)</code></li>
        </ul>
        <ul>
          <li>if <code>(a nroot k)</code> is rational, then <code>(a nroot k).pow(k)</code> = <code>a</code></li>
        </ul>
        <p>Approximate types like <code>Double</code> and <code>BigDecimal</code> have a built-in
        precision to which Spire can find roots. Exact types like <code>Rational</code>
        do not have <code>NRoot</code> instances defined by default, but instances can be
        instantiated with user-provided precision.</p>
        <p>Similarly, Spire supports the Trigonometric functions via
        <code>Trig[A]</code>. The preceding caveats about precision apply to these
        functions and values as well. The following methods are supported:</p>
        <ul>
          <li><code>e</code> Euler&#39;s number</li>
        </ul>
        <ul>
          <li><code>pi</code> Ratio of a circle&#39;s diameter to its circumference.</li>
        </ul>
        <ul>
          <li><code>exp(a)</code> Raise <code>e</code> to <code>a</code>-th power.</li>
        </ul>
        <ul>
          <li><code>expm1(a)</code> Equivalent to <code>exp(a) - 1</code> with less error.</li>
        </ul>
        <ul>
          <li><code>log(a)</code> Find the natural logarithm of <code>a</code> (<code>r</code> such that <code>expr(r)</code> = <code>a</code>)</li>
        </ul>
        <ul>
          <li><code>log1p(a)</code> Equivalent to <code>log(1 + a)</code> but with less error.</li>
        </ul>
        <ul>
          <li><code>sin(a)</code> Sine: the y-coordinate of the unit circle.</li>
        </ul>
        <ul>
          <li><code>cos(a)</code> Cosine: the x-coordinate of the unit circle.</li>
        </ul>
        <ul>
          <li><code>tan(a)</code> Tangent: equivalent to <code>sin(a) / cos(a)</code>.</li>
        </ul>
        <ul>
          <li><code>asin(a)</code> inverse sine function, <code>asin(sin(a))</code> = <code>a</code>.</li>
        </ul>
        <ul>
          <li><code>acos(a)</code> inverse cosine function, <code>acos(cos(a))</code> = <code>a</code>.</li>
        </ul>
        <ul>
          <li><code>atan(a)</code> inverse tangent function, <code>atan(tan(a))</code> = <code>a</code>.</li>
        </ul>
        <ul>
          <li><code>atan2(y, x)</code> like <code>atan</code> but returns results in <code>(-pi, pi]</code>.</li>
        </ul>
        <ul>
          <li><code>sinh(x)</code> hyperbolic sine, y-coordinate of the unit hyperbola.</li>
        </ul>
        <ul>
          <li><code>cosh(x)</code> hyperbolic cosine, x-coordinate of the unit hyperbola.</li>
        </ul>
        <ul>
          <li><code>tanh(x)</code> hyperbolic tangent, <code>sinh(a) / cosh(a)</code>.</li>
        </ul>
        <ul>
          <li><code>toRadians(a)</code> convert degrees (e.g. <code>180</code>) to pi-radians (e.g. <code>pi</code>)</li>
        </ul>
        <ul>
          <li><code>toDegrees(a)</code> convert pi-radians (e.g. <code>pi/2</code>) to degrees (e.g. <code>90</code>).</li>
        </ul>
        <p>Spire is able to calculate trigonometric values (like pi) and
        functions (like sine) to arbitrary precision when using
        <code>BigDecimal</code>. Unlike with <code>NRoot</code>, there is no support for creating
        <code>Trig[Rational]</code> instances with arbitrary precision (although an
        instance with <code>Double</code> precision can be found in
        <code>spire.optional.rationalTrig</code>).</p>
        
        <h4 id="modules-vectorspaces-co" class="section">Modules, VectorSpaces, &amp;co<a class="anchor-link right" href="#modules-vectorspaces-co"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>TODO</p>
        
        <h3 id="types" class="section">Types<a class="anchor-link right" href="#types"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>This section attempts to chronicle the existing number types in terms of their
        capabilities and problems.</p>
        
        <h4 id="byte-short-int-and-long" class="section">Byte, Short, Int, and Long<a class="anchor-link right" href="#byte-short-int-and-long"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>These built-in integral types are all signed and have a fixed-width (8, 16,
        32, and 64 bits respectively). Division with these types is truncated, and
        overflow can silently occur when numbers to get too big (or too small).
        Division by zero will trigger an exception.</p>
        <p>It&#39;s worth noting that the JVM does not support operating on <code>Byte</code> and
        <code>Short</code> directly: these operations will usually return <code>Int</code>. This can cause
        confusion when using type inference, and can also lead to differences between
        direct code (where adding bytes produces an int) and generic code (where
        adding bytes produces a byte).</p>
        
        <h4 id="float-and-double" class="section">Float and Double<a class="anchor-link right" href="#float-and-double"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>These fractional types correspond to IEEE-754 floating point (32- and 64-bit
        respectively). They contain three sentinel values: positive and negative
        infinity and NaN. Large positive and negative quantities will overflow to
        their respective infinity value, and division by zero will silently go to
        infinity.</p>
        <p>Comparison and equality semantics for NaN are tricky (for example NaN == NaN
        is false). This also means that there is no total ordering for doubles that
        complies with IEEE comparisons. For an alternate <code>Ordering[Double]</code> that is
        total, see <code>spire.optional.totalfloat</code>.</p>
        <p>Since floating-point values are approximations of real values, loss of
        precision can occur when adding values of different magnitudes. Thus, many
        operations are not always associative. Spire assumes that users who work with
        <code>Float</code> and <code>Double</code> are aware of these problems, and provides instances like
        <code>Ring[Double]</code> even though it will fail to be associative in some cases.</p>
        
        <h4 id="bigint" class="section">BigInt<a class="anchor-link right" href="#bigint"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This integral type is unbounded--it will never overflow (although operations
        will get slower and slower as the value gets larger). This is probably one of
        the least difficult types to use correctly.</p>
        
        <h4 id="bigdecimal" class="section">BigDecimal<a class="anchor-link right" href="#bigdecimal"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This fractional type is different than the previous floating point values. It
        contains a <code>MathContext</code> object which specifies a certain number of decimal
        digits of precision (34 by default). Results will be rounded to this level of
        precision, which also makes this type not associative in some cases (although
        with user-specified precision it is easier to avoid cases where this matters).</p>
        <p>The math context also defines how values should be rounded. Since this type is
        decimal, it can exactly represent any decimal number (unlike a floating point
        value) although its math context will need enough digits to do so.</p>
        <p>As with floating point, Spire makes a best effort to support this type even
        though there may be problems related to precision and rounding. Spire also
        provides capabilities which the underlying type lacks, including roots,
        fractional powers, and trigonometric methods.</p>
        
        <h4 id="rational" class="section">Rational<a class="anchor-link right" href="#rational"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This fractional type represents a rational number, a fraction of two integers
        (<code>n/d</code>). It is an exact type, although as you might expect it can&#39;t represent
        irrational numbers without approximating them as rationals. It is unbounded,
        although as the fraction becomes larger or more complex, operations will
        become slower. Rationals are always stored in simplest form to speed up future
        calculations.</p>
        <p>This is probably the easiest fractional type to use correctly.</p>
        
        <h4 id="safelong" class="section">SafeLong<a class="anchor-link right" href="#safelong"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This integral type is also unbounded, like <code>BigInt</code>. However, it is
        more efficient for small values, where it will use a <code>Long</code>
        instead. There is usually no reason to prefer using a <code>BigInt</code> over a
        <code>SafeLong</code> except to comply with an external API, or in cases where
        most values are expected to exceed a long&#39;s storage capacity.</p>
        
        <h4 id="natural" class="section">Natural<a class="anchor-link right" href="#natural"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This is a simple unbounded, unsigned integral type. It models natural
        numbers a as a cons list of digits (each &quot;digit&quot; being a 32-bit
        unsigned integer). For relatively small values (32-128 bits) it is
        often faster than <code>SafeLong</code> or <code>BigInt</code>. For larger values it becomes
        slower.</p>
        <p>The <code>Natural</code> type a bit of an odd-ball type at present. However the
        fact that it is guaranteed to be non-negative is useful.</p>
        
        <h4 id="ubyte-ushort-uint-and-ulong" class="section">UByte, UShort, UInt, and ULong<a class="anchor-link right" href="#ubyte-ushort-uint-and-ulong"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>These unsigned integral types are provided by Spire. They have most of
        the same operations as their signed counterparts, although they use
        unsigned division which is a bit more involved.</p>
        <p>They are value classes, so in most cases there should be no extra
        overhead when compared with their primitive counterparts. The one
        exception is with arrays. <code>Array[UInt]</code> will be boxed whereas
        <code>Array[Int]</code> is not. Since conversions between <code>UInt</code> and <code>Int</code> only
        exit at compile-time, it&#39;s easy to work around this issue by storing
        <code>UInt</code> instances in an <code>Array[Int]</code>.</p>
        <p>Writing literal unsigned values is slightly more cumbersome than their
        signed counterparts (consider <code>UInt(7)</code> versus <code>7</code>). Spire provides
        syntax imports which make these slightly easier to write:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">literals</span><span>.</span><span class="identifier">_</span><span>

</span><span class="string-literal">ui&quot;7&quot;</span><span> </span><span class="comment">// equivalent to UInt(7)
// res0: spire.math.UInt = 7</span></code></pre>
        
        <h4 id="fixedpoint" class="section">FixedPoint<a class="anchor-link right" href="#fixedpoint"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This value class uses a <code>Long</code> with an implicit denominator. The type
        itself doesn&#39;t contain information about the denominator. Instead, an
        implicit <code>FixedScale</code> instance is required to provide that context
        when necessary (for instance, during multiplication). Like the
        previous unsigned values, fixed point values will not be boxed in most
        cases.</p>
        <p>This type is designed to solve a specific type of problem and should
        only be used in situations where a large number of rational numbers
        with the same denominator are needed, and efficiency is very
        important.</p>
        
        <h4 id="complex-a-and-quaternion-a" class="section">Complex[A] and Quaternion[A]<a class="anchor-link right" href="#complex-a-and-quaternion-a"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>These generic types represent complex numbers (<code>x + yi</code>) and
        quaternions (<code>w + xi + xj + zk</code>) respectively. They can be
        parameterized with any fractional type <code>A</code> which has a <code>Field[A]</code>,
        <code>NRoot[A]</code>, and <code>Trig[A]</code>. In general these values are as exact as
        their underlying <code>A</code> values are, although in some cases approximate
        results are necessarily returned (in cases where roots or trigonometry
        functions are used).</p>
        <p>These types are specialized, so most operations should be quite fast
        and not cause unnecessary boxing. However, these types use more memory
        than a non-generic complex number based on <code>Double</code> values would, and
        are a bit slower.</p>
        
        <h4 id="number" class="section">Number<a class="anchor-link right" href="#number"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>This is a boxed number type that approximates the semantics of numbers
        in a dynamically-typed numeric tower (like Scheme or Python). There
        are four subtypes of <code>Number</code>, based on <code>SafeLong</code>, <code>Double</code>,
        <code>BigDecimal</code>, and <code>Rational</code>. Combining two numbers will always return
        a number of the highest precision.</p>
        <p><code>Number</code> is a good choice for users who want simple and correct
        numbers. The type keeps operations as safe as possible, while
        providing access to all operators and methods.</p>
        
        <h4 id="interval-a" class="section">Interval[A]<a class="anchor-link right" href="#interval-a"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Interval supports arithmetic across a range of possible <code>A</code>
        values. This can be thought of as representing uncertainty about a
        single, actual value, or as operating on the entire set of values
        simultaneously. Any type that has an <code>Order[A]</code> can be used in an
        interval, although most arithmetic operations will require additional
        type classes (ranging from <code>AdditiveSemigroup[A]</code> for <code>+</code> to
        <code>Field[A]</code> for <code>/</code>).</p>
        <p>Intervals may be unbounded on either side, and bounds can be open or
        closed.  (An interval includes closed boundaries, but not open
        boundaries). Here are some string representations of various
        intervals:</p>
        <ul>
          <li><code>[3, 6]</code> the set of values between 3 and 6 (including both).</li>
        </ul>
        <ul>
          <li><code>(2, 4)</code> the set of values between 2 and 4 (excluding both).</li>
        </ul>
        <ul>
          <li><code>[1, 2)</code> half-open set, including 1 but not 2.</li>
        </ul>
        <ul>
          <li><code>(-∞, 5)</code> the set of values less than 5.</li>
        </ul>
        <p>Intervals model continuous spaces, even if the type A is discrete. So
        for instance when <code>(3, 4)</code> is an <code>Interval[Int]</code> it is not considered
        &quot;empty&quot; , even though there are no <code>Int</code> values between 3 and 4. This
        is because we can multiply the interval by 2 to get <code>(6, 8)</code> which is
        clearly not empty. The underlying continuous interval contains values
        which when multiplied by a scalar become valid <code>Int</code> values.</p>
        
        <h4 id="polynomial-c" class="section">Polynomial[C]<a class="anchor-link right" href="#polynomial-c"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Currently Spire supports univariate polynomials. These are polynomials
        with a single variable (e.g. <em>x</em>) with the following structure:</p>
        <pre><code>c0 + (c1 * x^1) + (c2 * x^2) + ... + (cn * x^n)</code></pre>
        <p>The coefficients (<code>c0</code> through <code>cn</code>) are values of the type <code>C</code>, and
        the exponents (<code>1</code> through <code>n</code>) are <code>Int</code> values (this does mean that
        Spire&#39;s implementation only supports polynomials whose exponents are
        less than 2147483648).</p>
        <p>Like interval, arithmetic on polynomials is accomplished using type
        classes for <code>C</code>, such as <code>Semiring[C]</code>. With the right type classes,
        polynomials can support all the arithmetic operations covered by
        euclidean rings, but not fields. Division and reciprocal operations
        are impossible because polynomials do not support fractional or
        negative exponents. Polynomials also support <code>interval</code>, <code>derivative</code>,
        and other operations.</p>
        <p>Spire does support a convenient syntax for literal polynomials. By
        importing <code>spire.syntax.literals._</code> (or just <code>spire.implicits._</code>) you
        can use the <code>poly</code> string interpolator to create
        <code>Polynomial[Rational]</code> instances:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">literals</span><span>.</span><span class="identifier">_</span><span>

</span><span class="string-literal">poly&quot;3x^2 - 5x + 1&quot;</span><span>
</span><span class="comment">// res1: spire.math.Polynomial[spire.math.Rational] = PolySparse(
//   exp = Array(0, 1, 2),
//   coeff = Array(1, -5, 3)
// )
</span><span class="string-literal">poly&quot;5/4x^6 - 7x - 2&quot;</span><span>
</span><span class="comment">// res2: spire.math.Polynomial[spire.math.Rational] = PolySparse(
//   exp = Array(0, 1, 6),
//   coeff = Array(-2, -7, 5/4)
// )
</span><span class="string-literal">poly&quot;1.2x^3 - 6.1x^2 + 9x - 3.33&quot;</span><span>
</span><span class="comment">// res3: spire.math.Polynomial[spire.math.Rational] = PolySparse(
//   exp = Array(0, 1, 2, 3),
//   coeff = Array(-333/100, 9, -61/10, 6/5)
// )</span></code></pre>
        <p>Spire actually supports two types of polynomials: dense and
        sparse. For most simple polynomials used in these examples, you&#39;ll
        probably want dense polynomials. However, in cases where your
        polynomials have a few terms with very large exponents the sparse
        implementation will be more efficient. In any case, the underlying
        representation is an implementation detail and both types support the
        same operations (and can interoperate).</p>
        
        <h4 id="algebraic" class="section">Algebraic<a class="anchor-link right" href="#algebraic"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>The <code>Algebraic</code> type is an implementation of a number for &quot;Exact
        Geometric Computation&quot;. It represents algebraic numbers using an AST
        of the operations performed on it. <code>Algebraic</code> numbers can be compared
        accurately and exactly. This means that if we have two numbers <code>a</code> and
        <code>b</code>, then <code>a compare b</code> is always correct, regardless of whether they
        are irrational or incredibly close to each other. They are suitable
        for use in algorithms that use square- or n-roots and rely on sign
        tests and numeric comparison to work correctly.</p>
        <p>On top of exact comparisons/sign tests, <code>Algebraic</code> is able to
        approximate itself to any desired precision, after the fact. This
        works for both absolute approximations, such as <code>x +/- 0.00001</code>, or
        relative approximations, such as <code>x.toBigDecimal(new MathContext(10000))</code>.</p>
        <p>Because <code>Algebraic</code> can represent algebraic numbers (note: we are adding
        support for polynomial roots, not just n-roots), they have a wider range
        than <code>Rational</code>. However, whereas <code>Rational</code> represents numbers exactly,
        <code>Algebraic</code> can only compare exactly. They also sacrifice performance to
        achieve this, and so are not suitable for use where you need performance
        and can tolerate a certain amount of error.</p>
        
        <h4 id="real" class="section">Real<a class="anchor-link right" href="#real"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p><code>Real</code> stands for &quot;computable real&quot;. Spire&#39;s <code>Real</code> implementation is
        based on ERA, written in Haskell by David Lester. Computable real
        numbers are those which can be computed (i.e. approximated) to any
        desired precision. Unlike <code>Double</code> and <code>BigDecimal</code>, <code>Real</code> values are
        not stored as approximations, but rather as a function from a desired
        precision to the closest approximate value.</p>
        <p>If we have an instance <code>x</code> of <code>Real</code> which approximates a real number
        <em>r</em>, this means that for any precision <em>p</em> (in bits), our instance
        will produce an <em>x</em> such that <em>x/2^p</em> is the closest rational value to
        <em>r</em>. Translated into Scala, this means that <code>x.apply(p)</code> returns a
        <code>SafeLong</code> value <code>x</code>, such that <code>Rational(x, SafeLong(2).pow(p))</code> is a
        best approximation for <em>r</em>.</p>
        <p>Spire represents two types of <code>Real</code> values: <code>Exact</code> and
        <code>Inexact</code>. The former are rational values for which we have an
        existing instance of <code>Rational</code>, and are inexpensive to work with. The
        latter are functions for approximating (potentially) irrational
        values, are lazily evaluated and memoized, and can potentially be very
        expensive to compute.</p>
        <p>As with <code>Rational</code> values, operations on <code>Real</code> values are able to
        obey the relevant algebraic identities. But unlike <code>Rational</code>, <code>Real</code>
        supports roots and trigonometric functions. Furthermore, important
        trig identities are also preserved:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">math</span><span>.</span><span class="type-name">Real</span><span>

</span><span class="keyword">import</span><span> </span><span class="type-name">Real</span><span>.{</span><span class="identifier">sin</span><span>, </span><span class="identifier">cos</span><span>}

</span><span class="comment">// will return Real(1) no matter what value is provided
</span><span class="keyword">def</span><span> </span><span class="declaration-name">circle</span><span>(</span><span class="identifier">a</span><span>: </span><span class="type-name">Real</span><span>): </span><span class="type-name">Real</span><span> = </span><span class="identifier">sqrt</span><span>(</span><span class="identifier">cos</span><span>(</span><span class="identifier">a</span><span>).</span><span class="identifier">pow</span><span>(</span><span class="number-literal">2</span><span>) + </span><span class="identifier">sin</span><span>(</span><span class="identifier">a</span><span>).</span><span class="identifier">pow</span><span>(</span><span class="number-literal">2</span><span>))</span></code></pre>
        <p>Keep in mind that precision of roots is not perfectly accurate. See
        <a href="#irrational-and-transcendental-type-classes">Irrational and Transcendental type classes</a>
        for more information.</p>
        <p>One interesting consequence of the design of computable real numbers
        is non-continuous operations (such as sign tests, comparisons, and
        equality) cannot be performed exactly. If <code>x.apply(p)</code> returns <code>0</code>,
        there is no way to know whether the value is actually zero, or just a
        very small value (either positive or negative!) which is approximately
        zero at this precision. Similarly, it&#39;s not possible to say that <code>x</code>
        is equal to <code>y</code>, but only that they are equivalent (or not) at a given
        precision.</p>
        <p>Spire currently bakes in a &quot;default&quot; precision to use with these kinds
        of methods. Furthermore, these methods will always work with <code>Exact</code>
        values: the issues only arise when using <code>Inexact</code> values. Given that
        the alternative to using <code>Real</code> is to use another approximate type,
        providing approximate comparisons and equality seems like a reasonable
        compromise.</p>
        
        <h3 id="which-number-types-should-i-use" class="section">Which number types should I use?<a class="anchor-link right" href="#which-number-types-should-i-use"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>Spire provides many number types, and it is not always obvious what their
        relative merits are. This section explains the distinctions between them, and
        may help you decide which numeric representation(s) to use.</p>
        <p>There is usually a tension between numbers that have correctness caveats (like
        possible overflow or precision issues) and numbers that have performance
        caveats (like extra allocations and/or slower code). Spire provides a wide
        range of numeric types that should address most needs.</p>
        
        <h4 id="natural-numbers-unsigned-whole-value-numbers" class="section">Natural numbers (unsigned, whole-value numbers)<a class="anchor-link right" href="#natural-numbers-unsigned-whole-value-numbers"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>For non-negative numbers, the safe type to use is <code>Natural</code>. It is quite fast
        when representing small-ish numbers (128-bits or less), but has no upper bound
        on the values it can represent. However, its unique cons-structure means that
        for very large values <code>BigInt</code> and <code>SafeLong</code> may be faster. Since it only
        supports non-negative values, subtraction is non-total (and may throw an
        exception).</p>
        <p>If your values are guaranteed to be small (or you are prepared to detect
        truncation), you can use <code>UByte</code> (8-bit), <code>UShort</code> (16-bit), <code>UInt</code> (32-bit),
        or <code>ULong</code> (64-bit), depending on how much space you need. These types have
        the same unsigned semantics as unsigned types in languages like C. These types
        are not boxed, although care must be used with arrays (like any value class).</p>
        
        <h4 id="integer-numbers-signed-whole-value-numbers" class="section">Integer numbers (signed, whole-value numbers)<a class="anchor-link right" href="#integer-numbers-signed-whole-value-numbers"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>There are two safe types that can be used with integer values: <code>SafeLong</code> and
        <code>BigInt</code>. Both support arbitrarily large values, as well as the usual
        semantics for things like integer division (<code>quot</code>). The former (<code>SafeLong</code>)
        performs much better for values that can be represented with a <code>Long</code> (e.g.
        64-bit or less), and is a good default choice. When dealing with values that
        are mostly or entirely very large, <code>BigInt</code> may be a bit faster.</p>
        <p>Like the unsigned case, you can use <code>Byte</code> (8-bit), <code>Short</code> (16-bit), <code>Int</code>
        (32-bit), or <code>Long</code> (64-bit) to handle cases where your values are small, or
        where you want to avoid allocations and will handle truncation issues
        yourself. These types are provided by Scala (and ultimately the JVM) and will
        not cause object allocations.</p>
        
        <h4 id="fractional-numbers-numbers-that-can-be-divided" class="section">Fractional numbers (numbers that can be divided)<a class="anchor-link right" href="#fractional-numbers-numbers-that-can-be-divided"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>There are many different fractional flavors, which support various trade-offs
        between expressive power, precision, and performance.</p>
        <p>Fractional types come in two basic flavors: precise or imprecise. Imprecise
        types (like <code>Double</code>) will accumulate error and are not associative in some
        cases (meaning that <code>(x + y) + z</code> may produce different results than <code>x + (y +
z)</code>). These types are often faster than precise types but can be risky to use.</p>
        <p>Precise numbers make stronger precision guarantees, but at the cost of
        performance or expressiveness. They are often a bit slower, and may restrict
        the operations they support (to preserve guarantees about precision).</p>
        
        <h5 id="precise-types" class="section">Precise types<a class="anchor-link right" href="#precise-types"><i class="icofont-laika">&#xef71;</i></a></h5>
        <p>The most powerful precise type is <code>Real</code>. It represents computable real
        numbers, and supports all the operations you would expect, including roots and
        trigonometry. However, irrational values (like <code>Real(2).sqrt</code> or <code>Real.pi</code>)
        are represented via functions from precision to approximations. This means
        that in some situations this type might be too slow, or use too much memory.
        Additionally, operations requiring comparison or equality tests can only be
        approximately computed. However, this type should never accumulate error, so
        your results will always be correctly approximated to whatever precision you
        need.</p>
        <p>The next precise type is <code>Algebraic</code>. This type supports all rational values
        as well as roots. However, it cannot represent transcendental values like &quot;pi&quot;,
        making its values a subset of <code>Real</code>&#39;s. Unlike <code>Real</code>, this type is able to do
        exact sign tests (and thus, equality tests and comparisons). Due to the ASTs
        <code>Algebraic</code> uses to represent expressions, execution may be slow and involve
        lots of allocations.</p>
        <p>Finally there is <code>Rational</code>. This type represents values as irreducible
        fractions (e.g. <code>n/d</code>). <code>Rational</code> cannot represent irrational values (such as
        roots), but efficiently implements all operations on rational values. This
        type has the fewest performance &quot;gotchas&quot;, although obviously fractions with
        large numerators or denominators will take longer to operate on.</p>
        
        <h5 id="imprecise-types" class="section">Imprecise types<a class="anchor-link right" href="#imprecise-types"><i class="icofont-laika">&#xef71;</i></a></h5>
        <p>These types are more efficient than the precise types, but require care and
        analysis to ensure that results are correct and sufficiently accurate.</p>
        <p>The imprecise type with the most potential precision is <code>BigDecimal</code> which is
        provided by Scala. This number approximates real values to a number of decimal
        (base-10) digits (by default 34). Unlike floating point values, this type has
        an exact representation of values like <code>0.111110</code>, and the user can use
        <code>java.math.MathContext</code> to configure how much precision is used. Even so, the
        type is still subject to accumulated rounding error, and thus is not truly
        associative.</p>
        <p>Next come <code>Float</code> and <code>Double</code>, the built-in 32- and 64-bit floating-point
        implementations on the JVM. The pitfalls of using floating-point values are
        well-known (and documented elsewhere) but these types are very fast.</p>
        <p>Finally, Spire supports the experimental <code>FixedPoint</code> class. This value class
        uses unboxed <code>Long</code> values to represent fractions in terms of user-specified
        denominator (supplied via an implicit <code>FixedScale</code> instance). This is a very
        special-purpose type to be used in cases where floating-point approximations
        have problems and unboxed values are required. You should avoid this type
        unless your applications has a known, specific need for fixed-point
        arithmetic.</p>
        
        <h4 id="other-types" class="section">Other types<a class="anchor-link right" href="#other-types"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>The other numeric and pseudo-numeric types (like <code>Polynomial</code>, <code>Interval</code>,
        <code>Complex</code>, and <code>Quaternion</code>) each implement specific functionality, so there
        should be less confusion about which type to use. The sections describing
        these types explain their properties and trade-offs.</p>
        
        <h3 id="pseudo-random-number-generators-distributions-etc" class="section">Pseudo-Random Number Generators, Distributions, etc<a class="anchor-link right" href="#pseudo-random-number-generators-distributions-etc"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>Since Spire tries to make number types more pluggable in Scala code, it only
        makes sense that we&#39;d want to allow users to easily generate a wide variety of
        number types using pluggable PRNGs. The <code>spire.random</code> package contains random
        number generators appropriate to many different tasks, as well as a functional
        interface to creating uniform distributions of values.</p>
        
        <h4 id="pseudo-random-number-generators" class="section">Pseudo-Random Number Generators<a class="anchor-link right" href="#pseudo-random-number-generators"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p><strong>This section needs revising! Immutable generators have been replaced
        by the <code>Random[A]</code> monad, and the package structure has changed a bit!</strong></p>
        <p>Spire supports two types of PRNGs: mutable and immutable.</p>
        <p>The <code>mutable.Generator</code> trait represents a PRNG strategy. Using
        uniformly-generated <code>Int</code> or <code>Long</code> values it can generate random values,
        arrays of values, and so on. Defining a generator is relatively easy (for a
        very simple example see <code>Lcg64</code>).</p>
        <p>By default, generators are not threadsafe. A synchronized generator can be
        created from an unsynchronized one via the <code>sync</code> method. Generators can be
        copied, and their seeds can be saved and restored. This allows users to create
        deterministic streams of values by using the same seed. In general, it is
        preferred for users to create and use their own generators as opposed to
        relying on a single generator across threads.</p>
        <p>Although the <code>mutable.Generator</code> trait itself only provides low-level methods
        like <code>nextInt</code>, it can produce values of any type using the <code>Dist[A]</code> type
        class, which will be discussed in the next section.</p>
        <p>The <code>immutable.Generator</code> trait is similar to <code>mutable.Generator</code>, although
        the state it stores is immutable. Each time a number is generated a new
        generator is returned as well, which allows these generators to be used in a
        pure-functional context. The same <code>Dist[A]</code> instances that would be used with
        a mutable generator are also applicable here.</p>
        
        <h4 id="creation-random-values-with-dist-a" class="section">Creation random values with Dist[A]<a class="anchor-link right" href="#creation-random-values-with-dist-a"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>The <code>Dist[A]</code> type class represents a strategy for generating a
        distribution of <code>A</code> values given a <code>Generator</code> instance. <code>Dist[A]</code>
        makes no guarantee as to how the <code>A</code> values are distributed (for
        instance, it may always return the same value). Users who are
        interested in particular distributions should use the <code>Uniform[A]</code>,
        <code>Gaussian[A]</code>, and <code>Exponential[A]</code> traits to generate <code>Dist[A]</code>
        instances that correspond to their needs.</p>
        <p>The <code>Dist[A]</code> objects themselves are immutable and are powered by
        generators (both mutable and immutable). They can be transformed via
        <code>map</code>, <code>flatMap</code>, and other combinators. Given the appropriate
        structure on <code>A</code>, <code>Dist[A]</code> instances can also be operated on as if
        they were value.</p>
        
        <h4 id="distributions" class="section">Distributions<a class="anchor-link right" href="#distributions"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Currently, <code>spire.random</code> provides <code>Uniform[A]</code>, <code>Gaussian[A]</code>, and
        <code>Exponential[A]</code> type classes which given appropriate parameters can
        produce <code>Dist[A]</code> instances. Since most types have a (approximately)
        infinite number of possible values, bounds and other constraints need
        to be put on these types before we can usefully talk about (or
        implement) probability distributions in Spire.</p>
        <ul>
          <li>Given <code>min</code> and <code>max</code>, a <code>Uniform[A]</code> instance can produce a
          uniformly-distributed <code>Dist[A]</code> instance.</li>
        </ul>
        <ul>
          <li>Given <code>mean</code> and <code>stdDev</code>, a <code>Gaussian[A]</code> instance can produce a
          <code>Dist[A]</code> whose values are distributed according to the desired
          gaussian distribution.</li>
        </ul>
        <ul>
          <li>Given <code>rate</code>, a <code>Gaussian[A]</code> instance can produce a <code>Dist[A]</code>
          whose values are distributed according to the desired exponential
          distribution.</li>
        </ul>

        <hr style="margin-top: 30px"/>
        <footer style="font-size: 90%; text-align: center">
          spire is a <a href="https://typelevel.org/">Typelevel</a> project distributed under the <a href="https://opensource.org/licenses/MIT">MIT</a> license.
        </footer>

      </main>

    </div>

  </body>
</html>
